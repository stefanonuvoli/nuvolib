/*
 * This file is part of nuvolib: https://github.com/stefanonuvoli/nuvolib
 * This Source Code Form is subject to the terms of the GNU GPL 3.0
 *
 * @author Stefano Nuvoli (stefano.nuvoli@gmail.com)
 */
#include "animation_io_ska.h"

#include <nvl/math/matrix.h>
#include <nvl/math/translation.h>
#include <nvl/math/rotation.h>
#include <nvl/math/euler_angles.h>
#include <nvl/math/comparisons.h>

#include <nvl/utilities/file_utils.h>
#include <nvl/utilities/string_utils.h>
#include <nvl/utilities/locale_utils.h>

#include <fstream>

namespace nvl {

/**
 * @brief Load data from SKA file
 * @param filename filename
 * @param data Animation data
 * @param error Error
 * @return True if loading has been successful
 */
template<class T>
bool animationLoadDataFromSKA(
        const std::string& filename,
        IOAnimationData<T>& data,
        IOAnimationError& error)
{
    typedef typename T::Scalar Scalar;

    data.clear();

    std::ifstream fSka; //File streams

    fSka.imbue(streamDefaultLocale());

    std::string line;

    error = IO_ANIMATION_SUCCESS;

    //Open file
    fSka.open(filename);
    if(!fSka.is_open()) { //Error opening file
        error = IO_ANIMATION_FILE_ERROR;
        return false;
    }

    while (std::getline(fSka, line)) {
        std::istringstream iss(line);

        std::string token;
        iss >> token;

        if (token == "n") {
            data.name = stringUnion(iss);
        }
        else if (token[0] == 'k') {
            double time;
            iss >> time;

            data.times.push_back(time);
            data.transformations.push_back(std::vector<T>());
        }
        else if (token[0] == 's') {
            int index;

            iss >> index;            

            double t1, t2, t3;
            double r1, r2, r3;
            double s1 = 1.0, s2 = 1.0, s3 = 1.0;

            iss >> t1 >> t2 >> t3;
            iss >> r1 >> r2 >> r3;

            if (!iss.eof()) {
                iss >> s1 >> s2 >> s3;
            }

            Vector3<Scalar> ang(r1, r2, r3);
            for (EigenId i = 0; i < ang.size(); ++i) {
                ang[i] = ang[i] / 180.0 *  M_PI;
            }

            Rotation3<Scalar> rot = eulerAnglesToRotationXYZ(ang);
            Translation3<Scalar> tra(t1, t2, t3);
            Scaling3<Scalar> sca(s1, s2, s3);

            T transformation = tra * rot * sca;

            data.transformations[index].push_back(transformation);
        }
    }

    if (data.name.empty()) {
        std::string name = filenameName(filename);

        std::size_t prefixPos = name.find_last_of("@");

        if (prefixPos != std::string::npos) {
            name.erase(0, prefixPos + 1);
        }

        data.name = name;
    }

    fSka.close();

    //Successfully loaded
    return true;
}

/**
 * @brief Save data from SKA file
 * @param filename filename
 * @param data Animation data
 * @param error Error
 * @return True if saving has been successful
 */
template<class T>
bool animationSaveDataToSKA(
        const std::string& filename,
        const IOAnimationData<T>& data,
        IOAnimationError& error)
{
    typedef typename T::LinearMatrixType LinearMatrixType;
    typedef typename T::Scalar Scalar;

    std::ofstream fSka;

    fSka.imbue(streamDefaultLocale());

    error = IO_ANIMATION_SUCCESS;

    //Open file
    fSka.open(filename);
    if(!fSka.is_open()) { //Error opening file
        error = IO_ANIMATION_FILE_ERROR;
        return false;
    }

    //Set precision
    fSka.precision(6);
    fSka.setf(std::ios::fixed, std::ios::floatfield);

    fSka <<
            "###############################" << std::endl <<
            "# Generated by nuvolib (SKA)" << std::endl <<
            "# Animation SKA file" << std::endl <<
            "# Keyframes: " << data.transformations.size() << std::endl <<
            "# Duration: " << (data.times.empty() ? 0.0 : data.times[data.times.size() - 1]) << " seconds" << std::endl <<
            "###############################" << std::endl
            << std::endl;

    fSka << "n " << data.name << std::endl;

    for (Index i = 0; i < data.transformations.size(); ++i) {
        fSka << std::endl;

        const double& frameTime = data.times[i];
        fSka << "k " << frameTime << std::endl;

        const std::vector<T>& frameTransformations = data.transformations[i];
        for (const T& t : frameTransformations) {
            //Get data
            LinearMatrixType rotMatrix, scalMatrix;
            t.computeRotationScaling(&rotMatrix, &scalMatrix);
            Vector3<Scalar> traVec(t.translation());
            Rotation3<Scalar> rot(rotMatrix);
            Vector3<Scalar> scaVec(scalMatrix.diagonal());

            constexpr double eps = 1e-5;

            Vector3<Scalar> ang = eulerAnglesXYZFromRotation(rot);
            for (EigenId i = 0; i < ang.size(); ++i) {
                ang[i] = ang[i] / M_PI * 180.0;

                if (epsEqual(ang[i], 0.0, eps)) {
                    ang[i] = 0.0;
                }
            }

            for (EigenId i = 0; i < traVec.size(); ++i) {
                if (epsEqual(traVec[i], 0.0, eps)) {
                    traVec[i] = 0.0;
                }
            }

            bool scaling = false;
            for (EigenId i = 0; i < scaVec.size(); ++i) {
                if (epsEqual(scaVec[i], 1.0, eps)) {
                    scaVec[i] = 1.0;
                }
                else {
                    scaling = true;
                }
            }

            fSka << "s " << i;

            fSka << " " << traVec.x() << " " << traVec.y() << " " << traVec.z();

            fSka << " " << ang.x() << " " << ang.y() << " " << ang.z();

            if (scaling) {
                fSka << " " << scaVec.x() << " " << scaVec.y() << " " << scaVec.z();
            }

            fSka << std::endl;
        }
    }

    //Successfully loaded
    return true;
}

}
